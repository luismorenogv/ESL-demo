/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  xxmodel.c
 *  model: Jiwy-1
 *  expmt: Jiwy-1
 *  date:  June 25, 2025
 *  time:  12:21:48 PM
 *  user:  Vakgroep RaM
 *  from:  -
 *  build: 5.1.4.13773
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   PanDouble pan_variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   PanString pan_variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void PanCalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>
#include <string.h>

/* 20-sim include files */
#include "pan_xxmodel.h"
#include "xxfuncs.h"

/* the global variables */
PanDouble pan_start_time = 0.0;
PanDouble pan_finish_time = 30.0;
PanDouble pan_step_size = 0.01;
PanDouble pan_time = 0.0;
PanInteger pan_steps = 0;
PanBoolean pan_initialize = PanTRUE;
PanBoolean pan_major = PanTRUE;
PanBoolean pan_stop_simulation = PanFALSE;

/* the variable arrays */
PanDouble pan_P[pan_parameters_size];		/* parameters */
PanDouble pan_I[pan_initialvalues_size];		/* initial values */
PanDouble pan_V[pan_variables_size];		/* variables */
PanDouble pan_s[pan_states_size];		/* states */
PanDouble pan_R[pan_states_size];		/* rates (or new states) */

/* the names of the variables as used in the arrays above
   uncomment this part if these names are needed
PanString pan_parameter_names[] = {
	"corrGain\\K",
	"PID1\\kp",
	"PID1\\tauD",
	"PID1\\beta",
	"PID1\\tauI",
	"SignalLimiter2\\minimum",
	"SignalLimiter2\\maximum"
,	NULL
};
PanString pan_initial_value_names[] = {
	"PID1\\uD_previous_initial",
	"PID1\\error_previous_initial",
	"PID1\\uI_previous_initial"
,	NULL
};
PanString pan_variable_names[] = {
	"corrGain\\corr",
	"PID1\\output",
	"",
	"PlusMinus1\\plus1",
	"SignalLimiter2\\output",
	"Splitter1\\input",
	"corr",
	"in",
	"position",
	"out"
,	NULL
};
PanString pan_state_names[] = {
	"PID1\\uD_previous",
	"PID1\\error_previous",
	"PID1\\uI_previous"
,	NULL
};
PanString pan_rate_names[] = {
	"",
	"PID1\\error",
	""
,	NULL
};
*/

#if (7 > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif
void PanModelInitialize_parameters(void)
{
    /* set the parameters */
    pan_P[0] = 0.0;     /* corrGain\K */
    pan_P[1] = 15.0;        /* PID1\kp */
    pan_P[2] = 0.1; /* PID1\tauD */
    pan_P[3] = 0.5; /* PID1\beta */
    pan_P[4] = 50.0;        /* PID1\tauI */
    pan_P[5] = -0.99;   /* SignalLimiter2\minimum */
    pan_P[6] = 0.99;    /* SignalLimiter2\maximum */    
 
}
#if (7 > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

void PanModelInitialize_initialvalues(void)
{
	/* set the initial values */
	pan_I[0] = 0.0;		/* PID1\uD_previous_initial */
	pan_I[1] = 0.0;		/* PID1\error_previous_initial */
	pan_I[2] = 0.0;		/* PID1\uI_previous_initial */

}

void PanModelInitialize_states(void)
{
	/* set the states */
	pan_s[0] = pan_I[0];		/* PID1\uD_previous */
	pan_s[1] = pan_I[1];		/* PID1\error_previous */
	pan_s[2] = pan_I[2];		/* PID1\uI_previous */

}

void PanModelInitialize_variables(void)
{
	/* initialize the variable memory to zero */
	memset(pan_V, 0, pan_variables_size * sizeof(PanDouble));
}

/* this method is called before calculation is possible */
void PanModelInitialize (void)
{
	PanModelInitialize_parameters();
	PanModelInitialize_variables();
	PanModelInitialize_initialvalues();
	PanModelInitialize_states();
}

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void PanCalculateInitial (void)
{

	/* set the states again, they might have changed in the initial calculation */
	PanModelInitialize_states ();
}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void PanCalculateStatic (void)
{

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void PanCalculateInput (void)
{

}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void PanCalculateDynamic (void)
{
	/* PID1\factor = 1 / (sampletime + PID1\tauD * PID1\beta); */
	pan_V[2] = 1.0 / (pan_step_size + pan_P[2] * pan_P[3]);

	/* PlusMinus1\plus1 = in; */
	pan_V[3] = pan_V[7];

	/* Splitter1\input = position; */
	pan_V[5] = pan_V[8];

	/* corrGain\corr = corrGain\K * Splitter1\input; */
	pan_V[0] = pan_P[0] * pan_V[5];

	/* PID1\error = PlusMinus1\plus1 - Splitter1\input; */
	pan_R[1] = pan_V[3] - pan_V[5];

	/* PID1\uD = PID1\factor * (((PID1\tauD * PID1\uD_previous) * PID1\beta + (PID1\tauD * PID1\kp) * (PID1\error - PID1\error_previous)) + (sampletime * PID1\kp) * PID1\error); */
	pan_R[0] = pan_V[2] * (((pan_P[2] * pan_s[0]) * pan_P[3] + (pan_P[2] * pan_P[1]) * (pan_R[1] - pan_s[1])) + (pan_step_size * pan_P[1]) * pan_R[1]);

	/* PID1\uI = PID1\uI_previous + (sampletime * PID1\uD) / PID1\tauI; */
	pan_R[2] = pan_s[2] + (pan_step_size * pan_R[0]) / pan_P[4];

	/* PID1\output = PID1\uI + PID1\uD; */
	pan_V[1] = pan_R[2] + pan_R[0];

	/* SignalLimiter2\output = if PID1\output < SignalLimiter2\minimum... ; */
	pan_V[4] = ((pan_V[1] < pan_P[5]) ? 
		/* SignalLimiter2\minimum */
		pan_P[5]
	:
		/* if PID1\output > SignalLimiter2\maximum...  */
		((pan_V[1] > pan_P[6]) ? 
			/* SignalLimiter2\maximum */
			pan_P[6]
		:
			/* PID1\output */
			pan_V[1]
		)
	);


	/* increment the step counter */
	pan_steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void PanCalculateOutput (void)
{
	/* corr = corrGain\corr; */
	pan_V[6] = pan_V[0];

	/* out = SignalLimiter2\output; */
	pan_V[9] = pan_V[4];

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void PanCalculateFinal (void)
{

}

/* this method is called after all calculations are performed */
void PanModelTerminate(void)
{
}

